from pathlib import Path
import importlib
import sys
import warnings
from typing import Dict, List
import inspect


def discover_modules(pkg_path: Path) -> List[str]:
    names = []
    for p in pkg_path.iterdir():
        if p.name == "__init__.py":
            continue
        if p.is_file() and p.suffix == ".py":
            names.append(p.stem)
        elif p.is_dir() and (p / "__init__.py").exists():
            names.append(p.name)
    return sorted(set(names))


def collect_public_names(package: str, modules: List[str]) -> Dict[str, List[str]]:
    """
    Collect only classes that are actually defined in each module file.
    This filters out names that were imported from other modules (e.g. typing
    names like List/Optional or names re-exported from sibling modules).
    """
    collected = {}
    for m in modules:
        fq = f"{package}.{m}"
        try:
            mod = importlib.import_module(fq)
        except Exception as exc:
            warnings.warn(f"Skipping {fq}: import failed: {exc}", RuntimeWarning)
            raise ImportError(f"Failed to import {fq}") from exc
        names: List[str] = []
        for attr_name in dir(mod):
            if attr_name.startswith("_"):
                continue
            try:
                attr = getattr(mod, attr_name)
            except Exception:
                continue
            # only include classes that are defined in this module
            if inspect.isclass(attr) and getattr(attr, "__module__", None) == fq:
                names.append(attr_name)
        collected[m] = sorted(names)
    return collected


def render_init(package_short: str, modules_map: Dict[str, List[str]]) -> str:
    out_lines = [
        "# This file was autogenerated by scripts/init_gen.py",
        "# It statically re-exports public classes defined in sibling modules.",
        "",
    ]
    exported = []
    exported_set = set()

    # explicit imports for class names only; skip modules that export no classes
    for mod, names in modules_map.items():
        safe_names = [n for n in names if n and not n.startswith("_")]
        kept = []
        for n in safe_names:
            if n in exported_set:
                continue
            kept.append(n)
            exported_set.add(n)
            exported.append(n)
        if kept:
            out_lines.append(f"from .{mod} import " + ", ".join(kept))
    out_lines.append("")
    # final __all__ as literal list (classes only)
    out_lines.append("__all__ = [")
    for name in exported:
        out_lines.append(f"    {repr(name)},")
    out_lines.append("]")
    out_lines.append("")
    return "\n".join(out_lines)


def process_folder(pkg_path: Path, package: str) -> str:
    if not pkg_path.exists():
        print(f"Package path not found: {pkg_path}", file=sys.stderr)
        sys.exit(2)
    modules = discover_modules(pkg_path)
    modules_map = collect_public_names(package, modules)
    content = render_init(package.split(".")[-1], modules_map)
    return content


if __name__ == "__main__":
    folder = "../src/dataminer_sdk"
    pkg = "dataminer_sdk"
    print(process_folder(Path(folder), pkg))
